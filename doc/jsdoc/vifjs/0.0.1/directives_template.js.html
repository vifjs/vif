<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: directives/template.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: directives/template.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
    What append in a directive function ?
    1 - the directive function is stored inside component's schema
    2 - during the hydration process the directive function run with the following parameters
    3 - the directive function includes a reactive function, once activated it rerun every
        time a containing signal change. On every run the reactive function will trigger the
        expression with the new context (contains all this... values)
    4 - the result of the expression based on the context is used to update the directive
*/

import { xManager } from "../classes/manager.js";
import { signal } from "../reactivity/signal.js";
import { xcomment } from "../templates/html.js";
import { childrenOf, elementCloneNode } from "../utils/shortcuts.js";
import { VIF } from "../utils/types.js";
import { forDirective } from "./for.js";
import { ifDirective } from "./if.js";
import { routeDirective } from "./route.js";

/** @returns {Comment} */
export const createFlag = () => elementCloneNode(xcomment);

/**
 * create an abstract DOM part to manipulate a fragment
 * @param {VIF.Element.Datas} context
 * @param {number} index
 * @param {string} key
 * @param {any} value
 * @returns {VIF.Part}
 */
export const createPart = (context, index, key, value) => {
    /**
     * create a flag to identify the head and tail of the fragment
     * @type {Comment}
     */
    const flag = createFlag();

    /**
     * create a signal for the current array value
     * @type {VIF.Signal}
     */
    const property = key &amp;&amp; signal(value);

    // add index to property
    if (property) {
        property.index = index;
    }

    // create a manager to manage the fragment state and setup its context
    // 1 - clone the current context
    // 2 - add a new [key] or "item" property corresponding
    //     to signal of current array value
    const manager = new xManager(
        !key ? context : { ...context, [key]: property }
    );

    // return the part
    return { flag, manager, property };
};

export const addPart = (element, context, index, key, value) => {
    /** @type {Array&lt;VIF.Part>} */
    const parts = element.templateParts;

    /** @type {VIF.Part} */
    let part = parts[index + 1];

    /** @type {DocumentFragment} */
    const fragment = elementCloneNode(element.content, true);

    // we create the part corresponding to the fragment
    // the part will be stored into an array of parts
    // for each part we can retrieve the flag, the signal
    // for the current array item, and the manager which
    // store the context and the hydration methods
    // if the part already exist, update the property value
    if (part) {
        part.property &amp;&amp; part.property(value);
    } else {
        part = parts[index + 1] = createPart(context, index, key, value);
    }

    // if there is a cached schema, hydrate the fragment
    element.immutableSchema &amp;&amp;
        part.manager.hydrate(childrenOf(fragment), element.immutableSchema);

    // replace the current flag by himself plus fragment
    parts[index].flag.replaceWith(parts[index].flag, fragment, part.flag);
};

export const updatePart = (element, index, value) => {
    // find the part matching to the index and update the signal value
    element.templateParts[index + 1].property(value);
};

/**
 * remove a DOM part from the DOM and disconnect it
 * @param {Array&lt;VIF.Part>} parts
 * @param {number} index
 */
export const removePart = (element, index) => {
    /** @type {Array&lt;VIF.Part>} */
    const parts = element.templateParts;

    /**
     * get the head and tail flags
     * @type {Comment}
     */
    let head = parts[index].flag.nextSibling;
    const tail = parts[index + 1].flag;

    /**
     * disconnect the manager
     * @type {VIF.Part}
     */
    parts[index + 1].manager.disconnectCallback();

    /**
     * Remove all the elements between head and tail
     * move head forward after every deletion and stop
     * when head and tail are equals
     */
    while (head !== tail) {
        const prev = head;
        head = head.nextSibling;
        prev.remove();
    }
};

// setup template directives basics as element properties
export const setupTemplateDirective = (element) => {
    /** @type {Array&lt;VIF.Part>} */
    element.templateParts = [{ flag: createFlag() }];

    /** @type {VIF.Element.DisconnectCallback} */
    element.disconnectCallback = () => {
        for (let x = 1; x &lt; element.templateParts.length; x++) {
            element.templateParts[x].manager.disconnectCallback();
        }
    };

    // replace the current element by the main flag
    element.replaceWith(element.templateParts[0].flag);
};

/**
 * Retrieve the corresponding directive from the attribute name
 * @param {string} attributeName
 */
export const templateDirective = (attributeName) => {
    if (attributeName === "x-for") {
        return forDirective;
    } else if (attributeName === "x-if") {
        return ifDirective;
    } else if (attributeName === "x-route") {
        return routeDirective;
    }
};
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="xHandler.html">xHandler</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Vif">Vif</a></li><li><a href="global.html#attributeDirective">attributeDirective</a></li><li><a href="global.html#createCssSelector">createCssSelector</a></li><li><a href="global.html#createCssTemplateOrSelector">createCssTemplateOrSelector</a></li><li><a href="global.html#createEmptyTemplate">createEmptyTemplate</a></li><li><a href="global.html#createFlag">createFlag</a></li><li><a href="global.html#createLiteralTemplate">createLiteralTemplate</a></li><li><a href="global.html#createPart">createPart</a></li><li><a href="global.html#createReferenceArray">createReferenceArray</a></li><li><a href="global.html#createTemplateFragmentFromNodeList">createTemplateFragmentFromNodeList</a></li><li><a href="global.html#createTemplateFragmentFromString">createTemplateFragmentFromString</a></li><li><a href="global.html#createTemplateSchema">createTemplateSchema</a></li><li><a href="global.html#cssDirective">cssDirective</a></li><li><a href="global.html#cssNextId">cssNextId</a></li><li><a href="global.html#currentReactive">currentReactive</a></li><li><a href="global.html#dataDirective">dataDirective</a></li><li><a href="global.html#defaultDirective">defaultDirective</a></li><li><a href="global.html#define">define</a></li><li><a href="global.html#defineMemo">defineMemo</a></li><li><a href="global.html#disconnectReactive">disconnectReactive</a></li><li><a href="global.html#evaluatorMemo">evaluatorMemo</a></li><li><a href="global.html#eventDirective">eventDirective</a></li><li><a href="global.html#generateFunctionFromString">generateFunctionFromString</a></li><li><a href="global.html#i18n">i18n</a></li><li><a href="global.html#i18nMemo">i18nMemo</a></li><li><a href="global.html#i18nOnLoad">i18nOnLoad</a></li><li><a href="global.html#isDefined">isDefined</a></li><li><a href="global.html#isXAttribute">isXAttribute</a></li><li><a href="global.html#isXElement">isXElement</a></li><li><a href="global.html#isXEventAttribute">isXEventAttribute</a></li><li><a href="global.html#isXTemplate">isXTemplate</a></li><li><a href="global.html#locale">locale</a></li><li><a href="global.html#locales">locales</a></li><li><a href="global.html#navigate">navigate</a></li><li><a href="global.html#observe">observe</a></li><li><a href="global.html#observerDispacther">observerDispacther</a></li><li><a href="global.html#observerMemo">observerMemo</a></li><li><a href="global.html#reactive">reactive</a></li><li><a href="global.html#reconcile">reconcile</a></li><li><a href="global.html#refDirective">refDirective</a></li><li><a href="global.html#removePart">removePart</a></li><li><a href="global.html#showDirective">showDirective</a></li><li><a href="global.html#signal">signal</a></li><li><a href="global.html#templateDirective">templateDirective</a></li><li><a href="global.html#textDirective">textDirective</a></li><li><a href="global.html#translations">translations</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Fri Jan 19 2024 14:29:38 GMT+0100 (heure normale dâ€™Europe centrale)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
